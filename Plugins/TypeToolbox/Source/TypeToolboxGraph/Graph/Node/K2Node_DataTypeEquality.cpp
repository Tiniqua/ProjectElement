// Fill out your copyright notice in the Description page of Project Settings.

#include "K2Node_DataTypeEquality.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintFieldNodeSpawner.h"
#include "KismetCompilerMisc.h"
#include "EditorCategoryUtils.h"
#include "K2Node_CallFunction.h"
#include "KismetCompiler.h"
#include "TypeToolbox/DataType/BaseDataType.h"
#include "TypeToolbox/DataType/TypeToolboxLibrary.h"

#define LOCTEXT_NAMESPACE "UK2Node_DataTypeEquality"

UK2Node_DataTypeEquality::UK2Node_DataTypeEquality(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer) {}

void UK2Node_DataTypeEquality::AllocateDefaultPins()
{
	// Create the return value pin
	CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Boolean, UEdGraphSchema_K2::PN_ReturnValue);

	// Create the input pins for the data types A and B.
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Wildcard, TEXT("A"));
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Wildcard, TEXT("B"));
	
	Super::AllocateDefaultPins();
}

FText UK2Node_DataTypeEquality::GetTooltipText() const
{
	return LOCTEXT("DataTypeEqualityTooltip", "Returns true if the data types A & B are equal (A == B)");
}

FText UK2Node_DataTypeEquality::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	return LOCTEXT("EqualDataType", "Equal (DataType)");
}

void UK2Node_DataTypeEquality::PostReconstructNode()
{
	// Do type determination.
	PinConnectionListChanged(GetInput1Pin());
	PinConnectionListChanged(GetInput2Pin());
	Super::PostReconstructNode();
}

/** Determine if any pins are connected, if so make all the other pins the same type, if not, make sure pins are switched back to wildcards */
void UK2Node_DataTypeEquality::NotifyPinConnectionListChanged(UEdGraphPin* Pin)
{
	Super::NotifyPinConnectionListChanged(Pin);

	const UEdGraphSchema_K2* Schema = GetDefault<UEdGraphSchema_K2>();
	UEdGraphPin* InputPinA = GetInput1Pin();
	UEdGraphPin* InputPinB = GetInput2Pin();

	if (Pin == InputPinA || Pin == InputPinB)
	{
		if ((InputPinA->LinkedTo.Num() == 0) && (InputPinB->LinkedTo.Num() == 0))
		{
			InputPinA->PinType.PinCategory = Schema->PC_Wildcard;
			InputPinA->PinType.PinSubCategory = NAME_None;
			InputPinA->PinType.PinSubCategoryObject = nullptr;
			InputPinB->PinType.PinCategory = Schema->PC_Wildcard;
			InputPinB->PinType.PinSubCategory = NAME_None;
			InputPinB->PinType.PinSubCategoryObject = nullptr;
			Schema->SetPinAutogeneratedDefaultValueBasedOnType(InputPinA);
			Schema->SetPinAutogeneratedDefaultValueBasedOnType(InputPinB);
			GetGraph()->NotifyGraphChanged();
		}
		else if (Pin->LinkedTo.Num() > 0)
		{
			// Make sure the pin is a valid data type
			const UEdGraphPin* LinkedPin = Pin->LinkedTo[0];
			if (IsValidPin(LinkedPin))
			{
				Pin->PinType = LinkedPin->PinType;
				UEdGraphPin* OtherPin = (InputPinA == Pin) ? InputPinB : InputPinA;

				// Enforce the type on the other pin
				OtherPin->PinType = Pin->PinType;
				UEdGraphSchema_K2::ValidateExistingConnections(OtherPin);

				// Show drop down data type pin for other pin if not yet filled.
				if (OtherPin->LinkedTo.Num() <= 0 && OtherPin->DefaultValue.IsEmpty())
				{
					FString ValueString;
					const FDataTypeBase EmptyVal = FDataTypeBase();
					FDataTypeBase::StaticStruct()->ExportText(ValueString, &EmptyVal, nullptr, nullptr, EPropertyPortFlags::PPF_None, nullptr);
					Schema->SetPinAutogeneratedDefaultValue(OtherPin, ValueString);
					GetGraph()->NotifyGraphChanged();
				}
			}
			else
			{
				// A valid data type wasn't used to break the links
				Pin->BreakAllPinLinks();
			}
		}
		else if(Pin->DefaultValue.IsEmpty())
		{
			Schema->SetPinAutogeneratedDefaultValueBasedOnType(Pin);
		}
	}
}

bool UK2Node_DataTypeEquality::IsValidPin(const UEdGraphPin* InPin) const
{
	if (InPin->PinType.PinCategory != UEdGraphSchema_K2::PC_Struct ||
	!InPin->PinType.PinSubCategoryObject.IsValid())
	{
		return false;
	}

	const UStruct* IsStructClass = Cast<UStruct>(InPin->PinType.PinSubCategoryObject.Get());
	if (!IsStructClass || !IsStructClass->IsChildOf(FDataTypeBase::StaticStruct()))
	{
		return false;
	}

	return true;
}

bool UK2Node_DataTypeEquality::IsConnectionDisallowed(const UEdGraphPin* MyPin, const UEdGraphPin* OtherPin, FString& OutReason) const
{
	if (!MyPin || !OtherPin)
	{
		return true;
	}

	const bool bIsDataTypePin = IsValidPin(OtherPin);
	if (!bIsDataTypePin && (MyPin->Direction == EGPD_Input))
	{
		OutReason = LOCTEXT("InputIsNotDataType", "Cannot use the data type equality operator on anything but data types.").ToString();
		return true;
	}
	
	return false;
}

UEdGraphPin* UK2Node_DataTypeEquality::GetReturnValuePin() const
{
	UEdGraphPin* Pin = FindPin(UEdGraphSchema_K2::PN_ReturnValue);
	check(Pin);
	return Pin;
}

UEdGraphPin* UK2Node_DataTypeEquality::GetInput1Pin() const
{
	UEdGraphPin* Pin = FindPin(TEXT("A"));
	check(Pin);
	return Pin;
}

UEdGraphPin* UK2Node_DataTypeEquality::GetInput2Pin() const
{
	UEdGraphPin* Pin = FindPin(TEXT("B"));
	check(Pin);
	return Pin;
}

FName UK2Node_DataTypeEquality::GetConditionalFunctionName() const
{
	return GET_FUNCTION_NAME_CHECKED(UTypeToolboxLibrary, EqualEqual_DataTypeDataType);
}

FNodeHandlingFunctor* UK2Node_DataTypeEquality::CreateNodeHandler(FKismetCompilerContext& CompilerContext) const
{
	return new FNodeHandlingFunctor(CompilerContext);
}

void UK2Node_DataTypeEquality::ExpandNode(FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
	Super::ExpandNode(CompilerContext, SourceGraph);

	// Create the conditional node we're replacing the enum node for
	UK2Node_CallFunction* ConditionalNode = SourceGraph->CreateIntermediateNode<UK2Node_CallFunction>();
	ConditionalNode->FunctionReference.SetExternalMember(GetConditionalFunctionName(), UTypeToolboxLibrary::StaticClass());
	ConditionalNode->AllocateDefaultPins();
	CompilerContext.MessageLog.NotifyIntermediateObjectCreation(ConditionalNode, this);

	// Rewire the enum pins to the new conditional node
	UEdGraphPin* LeftSideConditionalPin = ConditionalNode->FindPinChecked(TEXT("A"));
	UEdGraphPin* RightSideConditionalPin = ConditionalNode->FindPinChecked(TEXT("B"));
	UEdGraphPin* ReturnConditionalPin = ConditionalNode->FindPinChecked(UEdGraphSchema_K2::PN_ReturnValue);
	UEdGraphPin* Input1Pin = GetInput1Pin();
	UEdGraphPin* Input2Pin = GetInput2Pin();

	// NOTE: PIN TYPES LEFT BLANK FOR THE CallFunction node override.
	// Got rid of this because plugging in any subtypes of FDataTypeBase to the wildcard would
	// cause errors in the CallFunction node expecting an exact type match with no exception to
	// child classes for FDataTypeBase.
	//LeftSideConditionalPin->PinType = Input1Pin->PinType;
	//RightSideConditionalPin->PinType = Input2Pin->PinType;
	
	CompilerContext.MovePinLinksToIntermediate(*Input1Pin, *LeftSideConditionalPin);
	CompilerContext.MovePinLinksToIntermediate(*Input2Pin, *RightSideConditionalPin);
	CompilerContext.MovePinLinksToIntermediate(*GetReturnValuePin(), *ReturnConditionalPin);

	// Break all links to the Select node so it goes away for at scheduling time
	BreakAllNodeLinks();
}

void UK2Node_DataTypeEquality::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	const UClass* ActionKey = GetClass();
	if (ActionRegistrar.IsOpenForRegistration(ActionKey))
	{
		UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
		check(NodeSpawner != nullptr);

		ActionRegistrar.AddBlueprintAction(ActionKey, NodeSpawner);
	}
}

FText UK2Node_DataTypeEquality::GetMenuCategory() const
{
	return FEditorCategoryUtils::GetCommonCategory(FCommonEditorCategory::Utilities);
}

#undef LOCTEXT_NAMESPACE